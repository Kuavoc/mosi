let textScript = `
return {

    drawNode: ({ nodes, nodeIndex = 0, canvas, context, fontData, fontDirection, timestamp, bgX = 0, bgY = 0, charsSoFar = 0, maxChars, spacingSoFar = 0, currentLine = 0, linesPerPage = 2 }) => {
        if (nodeIndex >= nodes.length) {
            return nodeIndex
        }

        let node = nodes[nodeIndex]

        if (node.type === 'text') {
            let nodeIsComplete = true

            // set position
            window.textPosition = node.position

            // find starting position
            let x = bgX + (fontData.width * 2)
            let y = (currentLine * fontData.height * 2) + bgY + (fontData.height * 2)

            // find widths of page and a single space
            let pageWidth = canvas.width - (fontData.width * 6)
            let spaceWidth = fontData.width

            // figure out if first word in node should be preceeded by a space
            let startWithSpace = node.text.startsWith(' ')
            let previousTextNodes = nodes.slice(0, nodeIndex).filter(n => n.type === 'text')
            if (previousTextNodes.length > 0) {
                let previousTextNode = previousTextNodes[previousTextNodes.length - 1]
                let previousText = previousTextNode.text
                if (previousText.endsWith(' ')) startWithSpace = true
            }

            // divide text into words
            let words = node.text.split(/\\s+/)

            // draw each word on screen
            for (let i = 0; i < words.length; i++) {
                let word = words[i]

                // ignore empty words
                if (!word) continue

                // add preceeding space if not first word in line or node
                if ((i > 0 || startWithSpace) && spacingSoFar > 0) word = ' ' + word

                // find how many characters are left
                let charsLeft = maxChars - charsSoFar
                if (maxChars >= 0 && charsLeft <= 0) {
                    return -1
                }

                // find how much space (pixels) left
                let spaceLeftOnLine = pageWidth - spacingSoFar

                // truncate word if needed
                let wordWidth = Text.textWidth(fontData, word)
                let displayWord = maxChars >= 0 ? word.substring(0, charsLeft) : word
                if (displayWord.length < word.length) {
                    nodeIsComplete = false
                }

                if (wordWidth <= spaceLeftOnLine || spacingSoFar === 0) {

                    // draw word
                    let seqWidth = Text.drawSeq(
                        context,
                        fontData,
                        fontDirection,
                        displayWord,
                        node.color,
                        node.style,
                        x + spacingSoFar,
                        y,
                        timestamp
                    )
                    spacingSoFar += seqWidth
                    charsSoFar += displayWord.length

                } else {

                    // put remaining text in new node
                    let remainingText = words.slice(i).join(' ')
                    if (remainingText.trim().length === 0) break
                    nodes.splice(nodeIndex + 1, 0, {
                        type: 'text',
                        text: remainingText,
                        color: node.color,
                        position: node.position,
                        style: node.style
                    })

                    // start new line
                    nodes.splice(nodeIndex + 1, 0, { type: 'line-break' })

                    // shorten this node
                    node.text = words.slice(0, i).join(' ')

                    break

                }
            }

            if (!nodeIsComplete) {
                return -1
            }
        }

        if (node.type === 'line-break') {
            currentLine += 1
            spacingSoFar = 0
            if (currentLine >= linesPerPage) {
                node.type = 'page-break'
            }
        }

        if (node.type === 'page-break') {
            currentLine = 0
            spacingSoFar = 0
            charsSoFar = 0
            return nodeIndex + 1
        }
        
        if (node.type === 'action') {
            // initialize list of local nodes
            let localNodes = []
            let addNode = (node) => {
                localNodes.push(node)
            }

            // run action
            node.actionFunc(addNode)

            // insert any nodes generated by action into list of nodes
            localNodes.forEach((node, i) => {
                nodes.splice(nodeIndex + 1 + i, 0, node)
            })
            // nodes = nodes.slice(0, nodeIndex + 1).concat(localNodes).concat(nodes.slice(nodeIndex + 1))

            // mark action as completed so it doesn't run again
            node.type = 'completed-action'
        }

        // draw next node
        return Text.drawNode({
            nodeIndex: nodeIndex + 1,
            nodes,
            canvas, context,
            fontData, fontDirection,
            timestamp,
            bgX, bgY,
            charsSoFar, maxChars,
            spacingSoFar, currentLine, linesPerPage
        })
    },

    drawBackground: (context, fontData, position, linesPerPage = 2) => {
        let bgWidth = context.canvas.width - (fontData.width * 2)
        let bgHeight = Math.floor(fontData.height * (linesPerPage * 2 + 3))
        let bgX = fontData.width
        let bgY
        if (position === 'top') {
            bgY = fontData.width
        } else if (position === 'bottom') {
            bgY = context.canvas.height - bgHeight - fontData.width
        } else {
            bgY = Math.floor(context.canvas.height / 2 - bgHeight / 2)
        }

        if (position === 'none') {
            // don't draw background
        } else if (position === 'fullscreen') {
            context.fillStyle = 'black'
            context.fillRect(0, 0, context.canvas.width, context.canvas.height)
        } else {
            context.fillStyle = 'black'
            context.fillRect(bgX, bgY, bgWidth, bgHeight)
        }

        return { bgX, bgY, bgWidth, bgHeight }
    },

    drawContinueIndicator: (context, fontData, bgX, bgY, bgWidth, bgHeight) => {
        let indicatorWidth = fontData.width
        let indicatorHeight = fontData.width
        let indicatorX = bgX + bgWidth - fontData.width - indicatorWidth
        let indicatorY = bgY + bgHeight - fontData.height - indicatorHeight
        context.fillStyle = 'white'
        context.fillRect(indicatorX, indicatorY, indicatorWidth, indicatorHeight)
    },

    textWidth: (fontData, text) => {
        let { width, characterList } = fontData
        let textWidth = 0
        for (let i = 0; i < text.length; i++) {
            let charCode = text.charCodeAt(i)
            let charData = characterList[charCode]
            if (!charData) continue
            let charWidth = !isNaN(charData.width) ? charData.width : width
            textWidth += charWidth
        }
        return textWidth
    },

    drawSeq: (context, fontData, fontDirection, text, color, style, x, y, timestamp, i = 0) => {
        context.fillStyle = color

        let numChars = text.length
        let spacingSoFar = 0

        for (let j = 0; j < numChars; j++) {
            let charCode = text.charCodeAt(j)
            let xOffset = (fontDirection === 'rtl') ? x - spacingSoFar : x + spacingSoFar
            let newSpacing = Text.drawChar(context, fontData, charCode, xOffset, y, style, timestamp, i + j)
            spacingSoFar += newSpacing
        }

        return spacingSoFar
    },

    drawChar: (context, fontData, charCode, x, y, style, timestamp, i) => {
        let { width, height, characterList } = fontData

        let charData = characterList[charCode]
        if (!charData) return 0

        if (!isNaN(charData.width)) width = charData.width
        if (!isNaN(charData.height)) height = charData.height

        let offsetX = 0
        let offsetY = 0
        if (!isNaN(charData.offsetX)) offsetX = charData.offsetX
        if (!isNaN(charData.offsetY)) offsetY = charData.offsetY

        let spacing = width
        if (!isNaN(charData.spacing)) spacing = charData.spacing

        let styleX = 0
        let styleY = 0
        if (style === 'wavy') {
            styleY = Math.floor(Math.sin(timestamp / (300) + (i / 2)) * (height / 3))
        }
        else if (style === 'shaky') {
            styleX = Math.floor(Math.cos(timestamp / (20) + i) * (width / 10))
            styleY = Math.floor(Math.sin(timestamp / (10) + i) * (height / 10))
        }

        for (let cx = 0; cx < width; cx++) {
            for (let cy = 0; cy < height; cy++) {
                let pixel = charData.data[cy * width + cx]
                if (pixel) {
                    context.fillRect(x + cx + offsetX + styleX, y + cy + offsetY + styleY, 1, 1)
                }
            }
        }

        return spacing
    }

}
`

let generateTextScript = new Function(textScript)
let Text = generateTextScript()